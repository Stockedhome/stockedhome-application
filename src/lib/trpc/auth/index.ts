import { createRouter, publicProcedure } from "../_trpc";
import { z } from "zod";
import { NextRequest } from "next/server";

import {
    generateRegistrationOptions,
    verifyRegistrationResponse,
    type GenerateRegistrationOptionsOpts,
    generateAuthenticationOptions,
    type GenerateAuthenticationOptionsOpts,
    verifyAuthenticationResponse,
    type VerifyAuthenticationResponseOpts,
} from '@simplewebauthn/server';

import type { ConfigSchemaBaseWithComputations } from "../../config/schema-base";
import { db } from "../../db";
import type { AuthPasskey, User } from "@prisma/client";
import { getServerSideReasonForInvalidPassword } from "./signup-checks/passwords/server";
import { EmailInvalidityReason } from "./signup-checks/emails/client";
import { PasswordInvalidityReason } from "./signup-checks/passwords/client";
import { getServerSideReasonForInvalidEmail } from "./signup-checks/emails/server";
import { getServerSideReasonForInvalidUsername } from "./signup-checks/usernames/server";
import { UsernameInvalidityReason } from "./signup-checks/usernames/client";
import { hashPassword } from "./passwordUtils";
import { cookies } from "next/headers";
import base64 from '@hexagon/base64';
import { STOCKEDHOME_COOKIE_NAME, SessionValidationFailureReason, authenticateUser, getExpectedOrigin, getSessionTokenFromRequest } from "../../auth";
import { authenticationResponseJSONSchema, publicKeyCredentialCreationOptionsJSONSchema, registrationResponseJSONSchema } from "@stockedhome/react-native-passkeys/src/ReactNativePasskeys.types";
import { castFromSimpleWebAuthnRegistrationOptions } from "@stockedhome/react-native-passkeys/casts";
import type { AuthenticatorTransportFuture } from "@simplewebauthn/types";
import { castToSimpleWebAuthnAuthenticationResponse, castToSimpleWebAuthnRegistrationResponse } from "@stockedhome/react-native-passkeys/src/casts";
import { getIpOrIpChain } from "../../device-identifiers";
import { validateCaptchaResponse } from "../../captcha";


interface DeviceIdentifier {
    /** User agent string */
    userAgent: string;
    /** A random, 24-character value generated by the client */
    clientGeneratedRandom: string;
}

function getDeviceIdentifier(req: NextRequest, clientGeneratedRandom: string): DeviceIdentifier {
    return {
        userAgent: req.headers.get('user-agent') || 'no-user-agent',
        clientGeneratedRandom,
    };
}

// If an attacker has physical access to your device, them accessing your grocery list is the least of your concerns
export const userVerification = 'discouraged' as const satisfies UserVerificationRequirement

function generateGenerateAuthenticationOptionsInput({ config, publicKeys, challenge }: {
    config: ConfigSchemaBaseWithComputations,
    publicKeys: Pick<AuthPasskey, 'clientId'|'clientTransports'>[],
    challenge: string,
}) {
    return {
        challenge,
        rpID: config.canonicalRoot.hostname,
        timeout: 1000 * 60 * 13, // 13 minutes -- two minutes before the DB row is pruned
        allowCredentials: publicKeys.map(key => ({
            id: key.clientId,
            transports: key.clientTransports as AuthenticatorTransportFuture[],
        })),
        userVerification,
    } as const satisfies GenerateAuthenticationOptionsOpts;
};

function generateGenerateRegistrationOptionsInput({ config, user, passkeys, challenge }: {
    config: ConfigSchemaBaseWithComputations,
    user: Pick<User, 'id'|'username'>,
    passkeys: Pick<AuthPasskey, 'clientId'|'clientTransports'>[],
    challenge: string,
}) {
    return {
        challenge,
        rpName: 'Stockedhome',
        rpID: config.canonicalRoot.hostname,
        userName: user.username,
        userDisplayName: user.username,
        userID: Uint8Array.from(Buffer.from(user.id.toString())),
        authenticatorSelection: {
            residentKey: 'preferred', // -- this shows a different prompt on mobile and, personally, I prefer the non-resident prompt
            userVerification,
            //authenticatorAttachment: 'cross-platform', -- nobody told me I could just, like, not define this and it doesn't filter
        },
        attestationType: 'none', // TODO: Test what this does and determine whether we want it for security purposes
        excludeCredentials: passkeys.map(key => ({
            id: key.clientId,
            transports: key.clientTransports as AuthenticatorTransportFuture[],
        })),
    } as const satisfies GenerateRegistrationOptionsOpts;
};
